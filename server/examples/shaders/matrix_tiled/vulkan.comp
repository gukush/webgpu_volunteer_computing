
#version 450
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform TileParams {
    uint matrix_n;
    uint tile_start_row;
    uint tile_start_col;
    uint tile_rows;
    uint tile_cols;
    uint tile_size;
} params;

layout(set = 0, binding = 1) readonly buffer InputData {
    float input_data[];
};

layout(set = 0, binding = 2) writeonly buffer TileOutput {
    float tile_output[];
};

void main() {
    uint local_row = gl_GlobalInvocationID.x;
    uint local_col = gl_GlobalInvocationID.y;
    
    // Bounds checking
    if (local_row >= params.tile_rows || local_col >= params.tile_cols) {
        return;
    }
    
    uint global_row = params.tile_start_row + local_row;
    uint global_col = params.tile_start_col + local_col;
    
    if (global_row >= params.matrix_n || global_col >= params.matrix_n) {
        return;
    }
    
    // Input layout: [matrix_size_header, A_data..., B_data...]
    uint header_size = 1;
    uint a_offset = header_size;
    uint b_offset = header_size + params.matrix_n * params.matrix_n;
    
    // Matrix multiplication: C[i,j] = sum(A[i,k] * B[k,j])
    float sum = 0.0;
    for (uint k = 0; k < params.matrix_n; k++) {
        float a_val = input_data[a_offset + global_row * params.matrix_n + k];
        float b_val = input_data[b_offset + k * params.matrix_n + global_col];
        sum += a_val * b_val;
    }
    
    // Store result in tile-local coordinates
    tile_output[local_row * params.tile_cols + local_col] = sum;
}
