#!/usr/bin/env node
// submit-task.mjs - Multi-framework extension with enhanced chunking system
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SUPPORTED_FRAMEWORKS = {
  'webgpu': { extension: '.wgsl', defaultEntry: 'main' },
  'webgl': { extension: '.glsl', defaultEntry: 'main' },
  'cuda': { extension: '.cu', defaultEntry: 'kernel' },
  'opencl': { extension: '.cl', defaultEntry: 'kernel' },
  'vulkan': { extension: '.comp', defaultEntry: 'main' }
};

function printHelp() {
  console.log(`
Multi-Framework Volunteer Computing Task Submission

Usage:
  # Traditional commands
  node submit-task.mjs matrix --size <int> --chunk <int> [--host <url>]
  node submit-task.mjs compute --framework <fw> --kernel <file> --label <name> --workgroups <x,y,z> --output-sizes <bytes1,bytes2> [options...]
  node submit-task.mjs wgsl --wgsl <file.wgsl> --label <name> --workgroups <x,y,z> --output-sizes <bytes> [options...]

  # Enhanced commands (new)
  node submit-task.mjs compute-advanced --framework <fw> --kernel <file> --chunking <strategy> --assembly <strategy> --metadata <json> [options...]
  node submit-task.mjs matrix-tiled --size <int> --tile-size <int> [--input <file>] [--label <name>]
  node submit-task.mjs sort --algorithm <alg> --array-size <int> [--chunk-size <int>] [--inputs <file>]
  node submit-task.mjs strategy-upload --type <chunking|assembly> --name <name> --file <strategy.js>
  node submit-task.mjs strategies-list
  node submit-task.mjs frameworks

  # System commands
  node submit-task.mjs compute-start
  node submit-task.mjs set-k --k <int>
  node submit-task.mjs workloads-rm --id <workloadId>

Frameworks:
  ${Object.keys(SUPPORTED_FRAMEWORKS).join(', ')}

Matrix Input Options:
  --input <file>             Direct path to combined matrix file (recommended)
  --inputs <inputs.json>     JSON file with input paths (fallback)

  If neither --input nor --inputs is provided, random matrices will be generated.

Multi-Input/Output Options:
  --inputs <inputs.json>     Multi-input JSON file: {"input_a": "./path_a.bin", "input_b": "./path_b.bin"}
  --input <file>             Single input file (backward compatibility)
  --output-sizes <n1,n2,n3>  Comma-separated output sizes (up to 3 outputs)
  --output-size <n>          Single output size (backward compatibility)
  --chunk-output-sizes <n1,n2,n3>  Per-chunk output sizes (for chunkable workloads)

Enhanced Compute Options:
  --framework <framework>     Computing framework (required)
  --kernel <file>            Kernel source file (required)
  --chunking <strategy>      Chunking strategy name or .js file (required)
  --assembly <strategy>      Assembly strategy name or .js file (required)
  --metadata <json>          Strategy-specific metadata (required)
  --label <name>             Human-readable label
  --compilation-opts <json>  Framework-specific options

Built-in Strategies:
  Chunking: linear, matrix_tiled, bitonic_sort
  Assembly: linear_assembly, matrix_tiled_assembly

Sorting Algorithms:
  bitonic    - Bitonic sort (requires power-of-2 array size)
  odd-even   - Odd-even sort (any size, often faster convergence)
  sample     - Sample sort (good for very large arrays)

Examples:
  # Matrix multiplication with generated data file
  node generate-matrix.mjs --size 1024 --output ./matrices
  node submit-task.mjs matrix-tiled --size 1024 --tile-size 64 --input ./matrices/matrices_1024x1024_float32.bin

  # Matrix multiplication with random data (no file)
  node submit-task.mjs matrix-tiled --size 512 --tile-size 32 --label "Random Test"

  # Multi-input/output compute workload
  node submit-task.mjs compute \\
    --framework webgpu \\
    --kernel ./multi_buffer.wgsl \\
    --inputs ./inputs.json \\
    --output-sizes 4096,2048,1024 \\
    --workgroups 64,1,1 \\
    --label "Multi-Buffer Processing"

  # Custom chunking strategy upload
  node submit-task.mjs strategy-upload --type chunking --name my_chunking --file ./my_strategy.js

  # Advanced workload with custom strategies
  node submit-task.mjs compute-advanced \\
    --framework webgpu \\
    --kernel ./image_blur.wgsl \\
    --chunking image_tiled \\
    --assembly image_tiled_assembly \\
    --metadata '{"imageWidth": 1920, "imageHeight": 1080, "tileSize": 128}' \\
    --inputs ./inputs.json \\
    --label "Image Blur Processing"

Matrix File Format:
  Generated by generate-matrix.mjs, the expected format is:
  - 4 bytes: matrix size (uint32, little endian)
  - size*size*4 bytes: Matrix A data (float32, little endian)
  - size*size*4 bytes: Matrix B data (float32, little endian)

Chunking Options (traditional):
  --chunkable                Enable input chunking
  --chunk-type <type>        Chunking type: elements|bytes
  --chunk-size <n>           Size per chunk
  --chunk-output-sizes <bytes1,bytes2> Output sizes per chunk (required for chunking)
  --elem-size <bytes>        Element size in bytes (for element chunking)
  --agg <method>             Output aggregation method: concatenate
`);
}

function parseArgs(argv) {
  const args = { _: [] };
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a.startsWith('--')) {
      const key = a.slice(2);
      const val = (i + 1 < argv.length && !argv[i+1].startsWith('--')) ? argv[++i] : true;
      args[key] = val;
    } else {
      args._.push(a);
    }
  }
  return args;
}

function hostBase(args) {
  return (args.host || process.env.TASK_HOST || 'https://localhost:3000').replace(/\/$/, '');
}


async function postMultipart(url, files) {
  const form = new FormData();
  for (const f of files) {
    // f: { name, buffer, filename }
    form.append(f.name, new Blob([f.buffer]), f.filename || f.name);
  }
  const res = await fetch(url, { method: 'POST', body: form });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status} ${res.statusText}: ${text}`);
  }
  return res.json();
}
async function postJSON(url, body) {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status} ${res.statusText}: ${text}`);
  }
  return res.json();
}

async function getJSON(url) {
  const res = await fetch(url);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status} ${res.statusText}: ${text}`);
  }
  return res.json();
}

async function del(url) {
  const res = await fetch(url, { method: 'DELETE' });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status} ${res.statusText}: ${text}`);
  }
  return res.json();
}

async function validateFramework(framework) {
  if (!SUPPORTED_FRAMEWORKS[framework]) {
    console.error(`Unsupported framework: ${framework}`);
    console.error(`Supported frameworks: ${Object.keys(SUPPORTED_FRAMEWORKS).join(', ')}`);
    process.exit(1);
  }
}

async function readKernelFile(filePath, framework) {
  try {
    const resolvedPath = path.resolve(filePath);
    const kernel = await fs.readFile(resolvedPath, 'utf8');

    // Validate file extension matches framework
    const expectedExt = SUPPORTED_FRAMEWORKS[framework].extension;
    const actualExt = path.extname(filePath);

    if (actualExt !== expectedExt) {
      console.warn(`Warning: File extension ${actualExt} doesn't match expected ${expectedExt} for ${framework}`);
    }

    return kernel;
  } catch (err) {
    console.error(`Failed to read kernel file ${filePath}: ${err.message}`);
    process.exit(1);
  }
}

async function parseCompilationOptions(optsString) {
  if (!optsString) return {};

  try {
    return JSON.parse(optsString);
  } catch (err) {
    console.error(`Invalid compilation options JSON: ${err.message}`);
    process.exit(1);
  }
}

// Enhanced helper functions
async function readStrategyFile(filePath, strategyType) {
  try {
    const resolvedPath = path.resolve(filePath);
    const strategyCode = await fs.readFile(resolvedPath, 'utf8');

    if (!strategyCode.includes('class') || !strategyCode.includes('extends')) {
      console.warn(`Warning: ${filePath} doesn't appear to contain a class extending Base${strategyType === 'chunking' ? 'Chunking' : 'Assembly'}Strategy`);
    }

    return strategyCode;
  } catch (err) {
    console.error(`Failed to read strategy file ${filePath}: ${err.message}`);
    process.exit(1);
  }
}

async function parseJSON(jsonString, context) {
  if (!jsonString) return {};

  try {
    return JSON.parse(jsonString);
  } catch (err) {
    console.error(`Invalid ${context} JSON: ${err.message}`);
    process.exit(1);
  }
}

async function resolveStrategy(strategyInput, strategyType, base) {
  if (strategyInput.endsWith('.js')) {
    console.log(`Will upload custom ${strategyType} strategy from ${strategyInput}...`);
    return `custom_${path.basename(strategyInput, '.js')}_${Date.now()}`;
  } else {
    return strategyInput;
  }
}

async function generateTestData(arraySize, outputFile, dataType = 'float32') {
  console.log(`Generating ${arraySize} ${dataType} test values...`);

  let buffer;

  if (dataType === 'float32') {
    const testArray = new Float32Array(arraySize);
    for (let i = 0; i < arraySize; i++) {
      testArray[i] = Math.random() * 1000;
    }
    buffer = Buffer.from(testArray.buffer);
  } else if (dataType === 'int32') {
    const testArray = new Int32Array(arraySize);
    for (let i = 0; i < arraySize; i++) {
      testArray[i] = Math.floor(Math.random() * 1000);
    }
    buffer = Buffer.from(testArray.buffer);
  }

  await fs.writeFile(outputFile, buffer);
  console.log(`Test data written to ${outputFile}`);
  return buffer;
}

// FIXED: Helper to pack two matrices into combined format expected by matrix tiled strategy
function packCombinedMatrices(size, A, B) {
  // Create buffer: [size_header, A_data..., B_data...]
  const buf = new ArrayBuffer(4 + size * size * 8); // 4 bytes header + 2 matrices
  const view = new DataView(buf);

  // Write size header
  view.setUint32(0, size, true);

  // Write matrix A
  const aOffset = 4;
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      view.setFloat32(aOffset + (i * size + j) * 4, A[i][j], true);
    }
  }

  // Write matrix B
  const bOffset = 4 + size * size * 4;
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      view.setFloat32(bOffset + (i * size + j) * 4, B[i][j], true);
    }
  }

  return Buffer.from(buf).toString('base64');
}

// Helper function to pack a single matrix
function packSingleMatrix(size, matrix) {
  const buf = new ArrayBuffer(4 + size * size * 4);  // size + matrix data
  const view = new DataView(buf);
  view.setUint32(0, size, true);

  let offset = 4;
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      view.setFloat32(offset, matrix[i][j], true);
      offset += 4;
    }
  }

  return Buffer.from(buf).toString('base64');
}

// NEW: Helper to load multiple inputs
async function loadInputs(args) {
  let inputJson = {};

  if (args.inputs) {
    // Multi-input JSON format
    try {
      const inputsConfigPath = path.resolve(args.inputs);
      const inputsConfig = JSON.parse(await fs.readFile(inputsConfigPath, 'utf8'));

      for (const [name, filePath] of Object.entries(inputsConfig)) {
        if (filePath) {
          const buf = await fs.readFile(path.resolve(filePath));
          inputJson[name] = buf.toString('base64');
        }
      }
    } catch (err) {
      console.error(`Failed to load inputs from ${args.inputs}: ${err.message}`);
      process.exit(1);
    }
  } else if (args.input) {
    // Backward compatibility: single input
    try {
      const buf = await fs.readFile(path.resolve(args.input));
      inputJson['input'] = buf.toString('base64');
    } catch (err) {
      console.error(`Failed to load input from ${args.input}: ${err.message}`);
      process.exit(1);
    }
  }

  return inputJson;
}

function parseOutputSizes(args) {
  let outputSizes = [];

  if (args['output-sizes']) {
    outputSizes = args['output-sizes'].split(',').filter(Boolean).map(n => parseInt(n, 10));
  } else if (args['output-size']) {
    // Backward compatibility
    outputSizes = [parseInt(args['output-size'], 10)];
  }

  // Validate sizes
  if (outputSizes.some(n => !Number.isInteger(n) || n <= 0)) {
    console.error('All output sizes must be positive integers');
    process.exit(1);
  }

  if (outputSizes.length > 3) {
    console.error('Maximum 3 outputs supported');
    process.exit(1);
  }

  return outputSizes;
}

// NEW: Helper to parse chunk output sizes
function parseChunkOutputSizes(args) {
  if (!args['chunk-output-sizes']) return [];

  const sizes = args['chunk-output-sizes'].split(',').filter(Boolean).map(n => parseInt(n, 10));

  if (sizes.some(n => !Number.isInteger(n) || n <= 0)) {
    console.error('All chunk output sizes must be positive integers');
    process.exit(1);
  }

  return sizes;
}

async function main() {
  const [, , cmd, ...rest] = process.argv;
  const args = parseArgs(rest);
  const base = hostBase(args);

  if (!cmd || args.help || args.h) return printHelp();

  // Traditional commands (unchanged)
  if (cmd === 'matrix') { console.error('Deprecated. Use matrix-tiled (advanced path).'); process.exit(1); }

  if (cmd === 'set-k') {
    const k = parseInt(args.k, 10);
    if (!Number.isInteger(k) || k < 1) {
      console.error('set-k: --k must be integer >= 1');
      process.exit(1);
    }
    const out = await postJSON(`${base}/api/system/k`, { k });
    console.log(JSON.stringify(out, null, 2));
    return;
  }

  if (cmd === 'matrix-tiled') {
    const size = parseInt(args.size, 10);
    const tileSize = parseInt(args['tile-size'], 10);
    const label = args.label || `Tiled Matrix ${size}×${size} (${tileSize}×${tileSize} tiles)`;

    if (!Number.isInteger(size) || !Number.isInteger(tileSize)) {
      console.error('matrix-tiled: --size and --tile-size are required integers');
      process.exit(1);
    }

    if (tileSize > size) {
      console.error('matrix-tiled: --tile-size cannot be larger than --size');
      process.exit(1);
    }

    let inputsJson;

    // Check if user provided a direct input file path
    if (args.input) {
      console.log(`Loading matrix data from: ${args.input}`);
      try {
        const inputPath = path.resolve(args.input);
        const buffer = await fs.readFile(inputPath);

        // Validate file size matches expected format
        const expectedSize = 4 + size * size * 2 * 4; // header + 2 matrices * 4 bytes per float32
        if (buffer.length !== expectedSize) {
          console.error(`Error: File size mismatch. Expected ${expectedSize} bytes, got ${buffer.length} bytes`);
          console.error(`Expected format: 4-byte header + ${size}×${size} matrix A + ${size}×${size} matrix B`);
          process.exit(1);
        }

        // Verify the size header matches
        const fileSizeHeader = buffer.readUInt32LE(0);
        if (fileSizeHeader !== size) {
          console.error(`Error: Size header mismatch. File header says ${fileSizeHeader}, but --size is ${size}`);
          process.exit(1);
        }

        inputsJson = {
          input: buffer.toString('base64')
        };

        console.log(` Loaded matrix data: ${buffer.length} bytes (${size}×${size} matrices)`);

      } catch (err) {
        console.error(`Failed to load matrix file ${args.input}: ${err.message}`);
        process.exit(1);
      }

    } else if (args.inputs) {
      // Fallback to JSON inputs format
      console.log('Loading matrix data from inputs JSON...');
      inputsJson = await loadInputs(args);

      if (Object.keys(inputsJson).length === 0 || !inputsJson.input) {
        console.error('matrix-tiled: Failed to load input data from provided JSON file');
        process.exit(1);
      }

      console.log('Using matrix data from inputs JSON');

    } else {
      // Generate random matrices as fallback
      console.log('No input files provided, generating random test matrices...');

      const A = Array.from({length:size}, () => Array.from({length:size}, () => Math.random()));
      const B = Array.from({length:size}, () => Array.from({length:size}, () => Math.random()));

      const combinedMatricesBuffer = packCombinedMatrices(size, A, B);

      inputsJson = {
        input: combinedMatricesBuffer
      };

      console.log(` Generated random ${size}×${size} test matrices`);
    }

    const payload = {
      label,
      framework: 'webgpu',
      chunkingStrategy: 'matrix_tiled',
      assemblyStrategy: 'matrix_tiled_assembly',
      metadata: { matrixSize: size, tileSize },
      input: JSON.stringify(inputsJson),
      outputSizes: [size * size * 4]  // Result matrix size in bytes
    };

    console.log(`Submitting matrix tiled workload: ${size}×${size} with ${tileSize}×${tileSize} tiles`);

    try {
      const out = await postJSON(`${base}/api/workloads/advanced`, payload);
      console.log(JSON.stringify(out, null, 2));
    } catch (err) {
      console.error('Failed to submit matrix-tiled workload:', err.message);
      process.exit(1);
    }

    return;
  }

  if (cmd === 'block-matrix') {
    const size = parseInt(args.size, 10);
    const blockSize = parseInt(args['block-size'], 10);
    const label = args.label || `Block Matrix ${size}×${size} (${blockSize}×${blockSize} blocks)`;

    if (!Number.isInteger(size) || !Number.isInteger(blockSize)) {
      console.error('block-matrix: --size and --block-size are required integers');
      process.exit(1);
    }
    if (size % blockSize !== 0) {
      console.error(`block-matrix: --size (${size}) must be divisible by --block-size (${blockSize})`);
      process.exit(1);
    }

    const payload = {
      label,
      framework: 'webgpu',
      chunkingStrategy: 'block_matrix',
      assemblyStrategy: 'block_matrix_assembly',
      metadata: { matrixSize: size, blockSize },
      outputSizes: [size * size * 4]
    };

    console.log('Submitting workload definition...');
    try {
      const workloadInfo = await postJSON(`${base}/api/workloads/advanced`, payload);
      const workloadId = workloadInfo.id;
      if (!workloadId) throw new Error('No workload ID returned');
      console.log(' Workload created:', workloadId);

      if (args.input) {
        const inputPath = path.resolve(args.input);
        const buf = await fs.readFile(inputPath);
        const expectedSize = 4 + size * size * 2 * 4;
        if (buf.length !== expectedSize) throw new Error(`File size mismatch: got ${buf.length}, expected ${expectedSize}`);
        if (buf.readUInt32LE(0) !== size) throw new Error(`Header mismatch in input file`);
        const upload = await postMultipart(`${base}/api/workloads/${workloadId}/inputs`, [
          { name: 'combined_matrix', buffer: buf, filename: path.basename(inputPath) }
        ]);
        console.log(' Upload complete:', upload);
      } else {
        console.log('Generating random matrices...');
        const A = Array.from({ length: size }, () => Array.from({ length: size }, () => Math.random()));
        const B = Array.from({ length: size }, () => Array.from({ length: size }, () => Math.random()));
        const buf = Buffer.from(packCombinedMatrices(size, A, B), 'base64');
        const upload = await postMultipart(`${base}/api/workloads/${workloadId}/inputs`, [
          { name: 'combined_matrix', buffer: buf, filename: `random_${size}x${size}.bin` }
        ]);
        console.log(' Random data uploaded:', upload);
      }
    } catch (err) {
      console.error('Failed to submit block-matrix workload:', err.message);
      process.exit(1);
    }
    return;
  }

  // Enhanced: Strategy upload
  if (cmd === 'strategy-upload') {
    const type = args.type;
    const name = args.name;
    const filePath = args.file;

    if (!type || !['chunking', 'assembly'].includes(type)) {
      console.error('strategy-upload: --type must be "chunking" or "assembly"');
      process.exit(1);
    }

    if (!name) {
      console.error('strategy-upload: --name is required');
      process.exit(1);
    }

    if (!filePath) {
      console.error('strategy-upload: --file is required');
      process.exit(1);
    }

    const strategyCode = await readStrategyFile(filePath, type);

    try {
      const out = await postJSON(`${base}/api/strategies/register`, {
        strategyCode,
        type,
        name
      });
      console.log(JSON.stringify(out, null, 2));
    } catch (err) {
      console.error('Failed to upload strategy:', err.message);
      process.exit(1);
    }
    return;
  }

  // Enhanced: List strategies
  if (cmd === 'strategies-list') {
    try {
      const out = await getJSON(`${base}/api/strategies`);
      console.log(JSON.stringify(out, null, 2));
    } catch (err) {
      console.error('Failed to fetch strategies:', err.message);
      process.exit(1);
    }
    return;
  }

  // Enhanced: Advanced compute workload
  if (cmd === 'compute-advanced') {
    const framework = args.framework;
    if (!framework) {
      console.error('compute-advanced: --framework is required');
      console.error(`Supported frameworks: ${Object.keys(SUPPORTED_FRAMEWORKS).join(', ')}`);
      process.exit(1);
    }

    await validateFramework(framework);

    if (!args.kernel) {
      console.error('compute-advanced: --kernel <file> is required');
      process.exit(1);
    }

    if (!args.chunking) {
      console.error('compute-advanced: --chunking <strategy> is required');
      process.exit(1);
    }

    if (!args.assembly) {
      console.error('compute-advanced: --assembly <strategy> is required');
      process.exit(1);
    }

    if (!args.metadata) {
      console.error('compute-advanced: --metadata <json> is required');
      process.exit(1);
    }

    const kernel = await readKernelFile(args.kernel, framework);
    const metadata = await parseJSON(args.metadata, 'metadata');
    const compilationOptions = await parseJSON(args['compilation-opts'], 'compilation options');

    const chunkingStrategy = await resolveStrategy(args.chunking, 'chunking', base);
    const assemblyStrategy = await resolveStrategy(args.assembly, 'assembly', base);

    // Load inputs
    const inputJson = await loadInputs(args);
    if (Object.keys(inputJson).length === 0) {
      console.error('compute-advanced: at least one input is required (use --inputs or --input)');
      process.exit(1);
    }

    const label = args.label || `Advanced ${framework.toUpperCase()} Workload`;
    const entry = args.entry || SUPPORTED_FRAMEWORKS[framework].defaultEntry;

    const payload = {
      label,
      chunkingStrategy,
      assemblyStrategy,
      framework,
      input: JSON.stringify(inputJson),
      metadata: {
        ...metadata,
        customShader: kernel,
        entry,
        compilationOptions
      }
    };

    // Add custom strategy files if provided
    if (args.chunking.endsWith('.js')) {
      payload.customChunkingFile = await readStrategyFile(args.chunking, 'chunking');
    }

    if (args.assembly.endsWith('.js')) {
      payload.customAssemblyFile = await readStrategyFile(args.assembly, 'assembly');
    }

    console.log(`Submitting advanced workload with strategies: ${chunkingStrategy} → ${assemblyStrategy}`);

    try {
      const out = await postJSON(`${base}/api/workloads/advanced`, payload);
      console.log(JSON.stringify(out, null, 2));
    } catch (err) {
      console.error('Failed to submit advanced workload:', err.message);
      process.exit(1);
    }
    return;
  }

  // Enhanced: Iterative sorting
  if (cmd === 'sort') {
    const algorithm = args.algorithm;
    const arraySize = parseInt(args['array-size'], 10);
    const chunkSize = parseInt(args['chunk-size'] || '64', 10);

    if (!algorithm || !['bitonic', 'odd-even', 'sample'].includes(algorithm)) {
      console.error('sort: --algorithm must be bitonic, odd-even, or sample');
      process.exit(1);
    }

    if (!Number.isInteger(arraySize) || arraySize <= 0) {
      console.error('sort: --array-size must be positive integer');
      process.exit(1);
    }

    if (algorithm === 'bitonic' && (arraySize & (arraySize - 1)) !== 0) {
      console.error('sort: bitonic sort requires power-of-2 array size');
      process.exit(1);
    }

    const inputJson = await loadInputs(args);
    let inputData;

    if (Object.keys(inputJson).length > 0) {
      inputData = JSON.stringify(inputJson);
    } else {
      console.log('No input file provided, generating random test data...');
      const testBuffer = await generateTestData(arraySize, `test_array_${arraySize}.bin`);
      inputData = JSON.stringify({ input: testBuffer.toString('base64') });
    }

    const strategyMap = {
      'bitonic': 'bitonic_sort',
      'odd-even': 'odd_even_sort',
      'sample': 'sample_sort'
    };

    const payload = {
      label: args.label || `${algorithm} sort ${arraySize} elements`,
      chunkingStrategy: strategyMap[algorithm],
      assemblyStrategy: 'linear_assembly',
      framework: 'webgpu',
      input: inputData,
      metadata: {
        arraySize,
        chunkSize,
        algorithm
      }
    };

    const out = await postJSON(`${base}/api/workloads/iterative`, payload);
    console.log(JSON.stringify(out, null, 2));
    return;
  }

  if (cmd === 'compute') { console.error('Deprecated. Use compute-advanced.'); process.exit(1); }

  // Backward compatibility: 'wgsl' command
  if (cmd === 'wgsl')   { console.error('Deprecated. Use compute-advanced.'); process.exit(1); }

  if (cmd === 'compute-start' || cmd === 'wgsl-start') {
    const out = await postJSON(`${base}/api/workloads/startQueued`, {});
    console.log(JSON.stringify(out, null, 2));
    return;
  }

  if (cmd === 'workloads-rm') {
    const id = args.id;
    if (!id) {
      console.error('workloads-rm: --id <workloadId> is required');
      process.exit(1);
    }
    const out = await del(`${base}/api/workloads/${encodeURIComponent(id)}`);
    console.log(JSON.stringify(out, null, 2));
    return;
  }

  if (cmd === 'frameworks') {
    try {
      const res = await fetch(`${base}/api/frameworks`);
      const data = await res.json();
      console.log(JSON.stringify(data, null, 2));
    } catch (err) {
      console.error('Failed to fetch framework info:', err.message);
      process.exit(1);
    }
    return;
  }

  printHelp();
}

main().catch(err => {
  console.error(err.message || err);
  process.exit(1);
});